[2020-04-15 15:54:43,410] {taskinstance.py:630} INFO - Dependencies all met for <TaskInstance: Create_Target_Tables.create_table 2020-04-15T15:53:45.023468+00:00 [queued]>
[2020-04-15 15:54:43,508] {taskinstance.py:630} INFO - Dependencies all met for <TaskInstance: Create_Target_Tables.create_table 2020-04-15T15:53:45.023468+00:00 [queued]>
[2020-04-15 15:54:43,509] {taskinstance.py:841} INFO - 
--------------------------------------------------------------------------------
[2020-04-15 15:54:43,509] {taskinstance.py:842} INFO - Starting attempt 1 of 1
[2020-04-15 15:54:43,509] {taskinstance.py:843} INFO - 
--------------------------------------------------------------------------------
[2020-04-15 15:54:43,530] {taskinstance.py:862} INFO - Executing <Task(PostgresOperator): create_table> on 2020-04-15T15:53:45.023468+00:00
[2020-04-15 15:54:43,530] {base_task_runner.py:133} INFO - Running: ['airflow', 'run', 'Create_Target_Tables', 'create_table', '2020-04-15T15:53:45.023468+00:00', '--job_id', '99', '--pool', 'default_pool', '--raw', '-sd', 'DAGS_FOLDER/test.py', '--cfg_path', '/tmp/tmp_lyt9f66']
[2020-04-15 15:54:45,099] {base_task_runner.py:115} INFO - Job 99: Subtask create_table /usr/local/lib/python3.7/site-packages/airflow/configuration.py:226: FutureWarning: The task_runner setting in [core] has the old default value of 'BashTaskRunner'. This value has been changed to 'StandardTaskRunner' in the running config, but please update your config before Apache Airflow 2.0.
[2020-04-15 15:54:45,100] {base_task_runner.py:115} INFO - Job 99: Subtask create_table   FutureWarning
[2020-04-15 15:54:45,100] {base_task_runner.py:115} INFO - Job 99: Subtask create_table /usr/local/lib/python3.7/site-packages/airflow/config_templates/airflow_local_settings.py:65: DeprecationWarning: The elasticsearch_host option in [elasticsearch] has been renamed to host - the old setting has been used, but please update your config.
[2020-04-15 15:54:45,100] {base_task_runner.py:115} INFO - Job 99: Subtask create_table   ELASTICSEARCH_HOST = conf.get('elasticsearch', 'HOST')
[2020-04-15 15:54:45,101] {base_task_runner.py:115} INFO - Job 99: Subtask create_table /usr/local/lib/python3.7/site-packages/airflow/config_templates/airflow_local_settings.py:67: DeprecationWarning: The elasticsearch_log_id_template option in [elasticsearch] has been renamed to log_id_template - the old setting has been used, but please update your config.
[2020-04-15 15:54:45,101] {base_task_runner.py:115} INFO - Job 99: Subtask create_table   ELASTICSEARCH_LOG_ID_TEMPLATE = conf.get('elasticsearch', 'LOG_ID_TEMPLATE')
[2020-04-15 15:54:45,101] {base_task_runner.py:115} INFO - Job 99: Subtask create_table /usr/local/lib/python3.7/site-packages/airflow/config_templates/airflow_local_settings.py:69: DeprecationWarning: The elasticsearch_end_of_log_mark option in [elasticsearch] has been renamed to end_of_log_mark - the old setting has been used, but please update your config.
[2020-04-15 15:54:45,101] {base_task_runner.py:115} INFO - Job 99: Subtask create_table   ELASTICSEARCH_END_OF_LOG_MARK = conf.get('elasticsearch', 'END_OF_LOG_MARK')
[2020-04-15 15:54:45,556] {base_task_runner.py:115} INFO - Job 99: Subtask create_table [2020-04-15 15:54:45,555] {settings.py:252} INFO - settings.configure_orm(): Using pool settings. pool_size=5, max_overflow=10, pool_recycle=1800, pid=2347
[2020-04-15 15:54:46,991] {base_task_runner.py:115} INFO - Job 99: Subtask create_table [2020-04-15 15:54:46,987] {__init__.py:51} INFO - Using executor LocalExecutor
[2020-04-15 15:54:46,991] {base_task_runner.py:115} INFO - Job 99: Subtask create_table [2020-04-15 15:54:46,989] {dagbag.py:92} INFO - Filling up the DagBag from /usr/local/airflow/dags/test.py
[2020-04-15 15:54:47,084] {base_task_runner.py:115} INFO - Job 99: Subtask create_table [2020-04-15 15:54:47,083] {cli.py:545} INFO - Running <TaskInstance: Create_Target_Tables.create_table 2020-04-15T15:53:45.023468+00:00 [running]> on host 782305ba671a
[2020-04-15 15:54:47,146] {postgres_operator.py:62} INFO - Executing: -- Set up Target table company, company_audits, log_last_company_audits_changes function and last_company_audits_changes trigger

drop view if exists last_address_record_inserted;
drop view if exists last_company_record_inserted;
drop trigger if exists last_address_audits_changes on public.address;
drop trigger if exists log_last_address on public.address;
drop trigger if exists last_company_audits_changes on public.company;
drop trigger if exists log_last_company on public.company;
drop function if exists log_last_address_audits_changes();
drop function if exists log_last_table();
drop function if exists log_last_company_audits_changes();
drop table if exists address;
drop table if exists address_audits;
drop table if exists company;
drop table if exists company_audits;
drop table if exists occupations;
drop table if exists last_insert_audits;

CREATE TABLE company
(
    company_id text COLLATE pg_catalog."default",
    status character varying(255) COLLATE pg_catalog."default",
    rating_threshold character varying(255) COLLATE pg_catalog."default",
    company_name text COLLATE pg_catalog."default",
    foundation_date date,
    legal_form character varying(255) COLLATE pg_catalog."default",
    created_at date
);

CREATE TABLE IF NOT EXISTS company_audits (
   id SERIAL PRIMARY KEY,
   company_id text COLLATE pg_catalog."default",
   changed_on TIMESTAMP(6) NOT NULL
);

CREATE OR REPLACE FUNCTION public.log_last_company_audits_changes()
  RETURNS trigger AS
  $BODY$
  BEGIN
     IF EXISTS(SELECT 1 FROM company c WHERE c.company_id = NEW.company_id) THEN
           PERFORM * FROM company_audits LIMIT 1;
     ELSE
           INSERT INTO company_audits(company_id,changed_on) VALUES(NEW.company_id,now());
     END IF;
     RETURN NEW;
  END;
  $BODY$
    LANGUAGE plpgsql;

CREATE TRIGGER last_company_audits_changes
  BEFORE INSERT
  ON company
  FOR EACH ROW
  EXECUTE PROCEDURE log_last_company_audits_changes();

-- Set up Target table address, address_audits, log_last_address_audits_changes function and last_address_audits_changes trigger

CREATE TABLE address
(
    id integer,
    company_id text COLLATE pg_catalog."default",
    country character varying(255) COLLATE pg_catalog."default",
    postal_code character varying(255) COLLATE pg_catalog."default",
    city character varying(255) COLLATE pg_catalog."default",
    district character varying(255) COLLATE pg_catalog."default",
    street character varying(255) COLLATE pg_catalog."default",
    street_number character varying(255) COLLATE pg_catalog."default",
    addition character varying(255) COLLATE pg_catalog."default",
    created_at date
);

CREATE TABLE IF NOT EXISTS address_audits (
   idx SERIAL PRIMARY KEY,
   id integer,
   company_id text COLLATE pg_catalog."default",
   changed_on TIMESTAMP(6) NOT NULL
);

CREATE OR REPLACE FUNCTION public.log_last_address_audits_changes()
  RETURNS trigger AS
  $BODY$
  BEGIN
     IF EXISTS(SELECT 1 FROM address a WHERE a.id = NEW.id) THEN
           PERFORM * FROM address_audits LIMIT 1;
     ELSE
           INSERT INTO address_audits(id,company_id,changed_on) VALUES(NEW.id, NEW.company_id,now());
     END IF;
     RETURN NEW;
  END;
  $BODY$
     LANGUAGE plpgsql;

CREATE TRIGGER last_address_audits_changes
  BEFORE INSERT
  ON address
  FOR EACH ROW
  EXECUTE PROCEDURE log_last_address_audits_changes();

-- Set up Target table last record insert tracker as view last_address_record_inserted, last_company_record_inserted

CREATE OR REPLACE VIEW last_address_record_inserted AS
SELECT a.id, a.company_id, a.country, a.postal_code,
a.city, a.district, a.street, a.street_number, a.addition, a.created_at FROM address a
inner join (SELECT id from address_audits where changed_on = (
SELECT changed_on FROM public.address_audits order by changed_on desc limit 1)) as b
on a.id = b.id;

CREATE OR REPLACE VIEW last_company_record_inserted AS
SELECT a.company_id, a.status, a.rating_threshold, a.company_name,
a.foundation_date, a.legal_form, a.created_at FROM company a
inner join (SELECT company_id from company_audits where changed_on = (
SELECT changed_on FROM public.company_audits order by changed_on desc limit 1))as b
on a.company_id = b.company_id;


CREATE TABLE IF NOT EXISTS last_insert_audits (
   idx SERIAL PRIMARY KEY,
   table_name text COLLATE pg_catalog."default",
   insert_on TIMESTAMP(6) NOT NULL
);


CREATE OR REPLACE FUNCTION log_last_table()
   RETURNS trigger AS $$
   DECLARE arg text COLLATE pg_catalog."default";
   BEGIN
      FOREACH arg IN ARRAY TG_ARGV LOOP
        INSERT INTO last_insert_audits(table_name,insert_on) VALUES(arg,now());
      END LOOP;
      RETURN NEW;
   END;
   $$ LANGUAGE plpgsql;


CREATE TRIGGER log_last_address
  BEFORE INSERT
  ON address
  EXECUTE PROCEDURE log_last_table('address');

CREATE TRIGGER log_last_company
  BEFORE INSERT
  ON company
  EXECUTE PROCEDURE log_last_table('company');
[2020-04-15 15:54:47,168] {logging_mixin.py:112} INFO - [2020-04-15 15:54:47,168] {base_hook.py:84} INFO - Using connection to: id: target. Host: sourcedb, Port: 5432, Schema: targetdb, Login: sourcedb, Password: XXXXXXXX, extra: {}
[2020-04-15 15:54:47,172] {logging_mixin.py:112} INFO - [2020-04-15 15:54:47,172] {dbapi_hook.py:171} INFO - -- Set up Target table company, company_audits, log_last_company_audits_changes function and last_company_audits_changes trigger

drop view if exists last_address_record_inserted;
drop view if exists last_company_record_inserted;
drop trigger if exists last_address_audits_changes on public.address;
drop trigger if exists log_last_address on public.address;
drop trigger if exists last_company_audits_changes on public.company;
drop trigger if exists log_last_company on public.company;
drop function if exists log_last_address_audits_changes();
drop function if exists log_last_table();
drop function if exists log_last_company_audits_changes();
drop table if exists address;
drop table if exists address_audits;
drop table if exists company;
drop table if exists company_audits;
drop table if exists occupations;
drop table if exists last_insert_audits;

CREATE TABLE company
(
    company_id text COLLATE pg_catalog."default",
    status character varying(255) COLLATE pg_catalog."default",
    rating_threshold character varying(255) COLLATE pg_catalog."default",
    company_name text COLLATE pg_catalog."default",
    foundation_date date,
    legal_form character varying(255) COLLATE pg_catalog."default",
    created_at date
);

CREATE TABLE IF NOT EXISTS company_audits (
   id SERIAL PRIMARY KEY,
   company_id text COLLATE pg_catalog."default",
   changed_on TIMESTAMP(6) NOT NULL
);

CREATE OR REPLACE FUNCTION public.log_last_company_audits_changes()
  RETURNS trigger AS
  $BODY$
  BEGIN
     IF EXISTS(SELECT 1 FROM company c WHERE c.company_id = NEW.company_id) THEN
           PERFORM * FROM company_audits LIMIT 1;
     ELSE
           INSERT INTO company_audits(company_id,changed_on) VALUES(NEW.company_id,now());
     END IF;
     RETURN NEW;
  END;
  $BODY$
    LANGUAGE plpgsql;

CREATE TRIGGER last_company_audits_changes
  BEFORE INSERT
  ON company
  FOR EACH ROW
  EXECUTE PROCEDURE log_last_company_audits_changes();

-- Set up Target table address, address_audits, log_last_address_audits_changes function and last_address_audits_changes trigger

CREATE TABLE address
(
    id integer,
    company_id text COLLATE pg_catalog."default",
    country character varying(255) COLLATE pg_catalog."default",
    postal_code character varying(255) COLLATE pg_catalog."default",
    city character varying(255) COLLATE pg_catalog."default",
    district character varying(255) COLLATE pg_catalog."default",
    street character varying(255) COLLATE pg_catalog."default",
    street_number character varying(255) COLLATE pg_catalog."default",
    addition character varying(255) COLLATE pg_catalog."default",
    created_at date
);

CREATE TABLE IF NOT EXISTS address_audits (
   idx SERIAL PRIMARY KEY,
   id integer,
   company_id text COLLATE pg_catalog."default",
   changed_on TIMESTAMP(6) NOT NULL
);

CREATE OR REPLACE FUNCTION public.log_last_address_audits_changes()
  RETURNS trigger AS
  $BODY$
  BEGIN
     IF EXISTS(SELECT 1 FROM address a WHERE a.id = NEW.id) THEN
           PERFORM * FROM address_audits LIMIT 1;
     ELSE
           INSERT INTO address_audits(id,company_id,changed_on) VALUES(NEW.id, NEW.company_id,now());
     END IF;
     RETURN NEW;
  END;
  $BODY$
     LANGUAGE plpgsql;

CREATE TRIGGER last_address_audits_changes
  BEFORE INSERT
  ON address
  FOR EACH ROW
  EXECUTE PROCEDURE log_last_address_audits_changes();

-- Set up Target table last record insert tracker as view last_address_record_inserted, last_company_record_inserted

CREATE OR REPLACE VIEW last_address_record_inserted AS
SELECT a.id, a.company_id, a.country, a.postal_code,
a.city, a.district, a.street, a.street_number, a.addition, a.created_at FROM address a
inner join (SELECT id from address_audits where changed_on = (
SELECT changed_on FROM public.address_audits order by changed_on desc limit 1)) as b
on a.id = b.id;

CREATE OR REPLACE VIEW last_company_record_inserted AS
SELECT a.company_id, a.status, a.rating_threshold, a.company_name,
a.foundation_date, a.legal_form, a.created_at FROM company a
inner join (SELECT company_id from company_audits where changed_on = (
SELECT changed_on FROM public.company_audits order by changed_on desc limit 1))as b
on a.company_id = b.company_id;


CREATE TABLE IF NOT EXISTS last_insert_audits (
   idx SERIAL PRIMARY KEY,
   table_name text COLLATE pg_catalog."default",
   insert_on TIMESTAMP(6) NOT NULL
);


CREATE OR REPLACE FUNCTION log_last_table()
   RETURNS trigger AS $$
   DECLARE arg text COLLATE pg_catalog."default";
   BEGIN
      FOREACH arg IN ARRAY TG_ARGV LOOP
        INSERT INTO last_insert_audits(table_name,insert_on) VALUES(arg,now());
      END LOOP;
      RETURN NEW;
   END;
   $$ LANGUAGE plpgsql;


CREATE TRIGGER log_last_address
  BEFORE INSERT
  ON address
  EXECUTE PROCEDURE log_last_table('address');

CREATE TRIGGER log_last_company
  BEFORE INSERT
  ON company
  EXECUTE PROCEDURE log_last_table('company');
[2020-04-15 15:54:47,241] {postgres_operator.py:67} INFO - NOTICE:  view "last_address_record_inserted" does not exist, skipping

[2020-04-15 15:54:47,241] {postgres_operator.py:67} INFO - NOTICE:  view "last_company_record_inserted" does not exist, skipping

[2020-04-15 15:54:47,241] {postgres_operator.py:67} INFO - NOTICE:  relation "public.address" does not exist, skipping

[2020-04-15 15:54:47,241] {postgres_operator.py:67} INFO - NOTICE:  relation "public.address" does not exist, skipping

[2020-04-15 15:54:47,241] {postgres_operator.py:67} INFO - NOTICE:  relation "public.company" does not exist, skipping

[2020-04-15 15:54:47,241] {postgres_operator.py:67} INFO - NOTICE:  relation "public.company" does not exist, skipping

[2020-04-15 15:54:47,241] {postgres_operator.py:67} INFO - NOTICE:  table "address" does not exist, skipping

[2020-04-15 15:54:47,241] {postgres_operator.py:67} INFO - NOTICE:  table "company" does not exist, skipping

[2020-04-15 15:54:47,241] {postgres_operator.py:67} INFO - NOTICE:  table "occupations" does not exist, skipping

[2020-04-15 15:54:48,350] {logging_mixin.py:112} INFO - [2020-04-15 15:54:48,350] {local_task_job.py:124} WARNING - Time since last heartbeat(0.05 s) < heartrate(5.0 s), sleeping for 4.949809 s
[2020-04-15 15:54:53,302] {logging_mixin.py:112} INFO - [2020-04-15 15:54:53,301] {local_task_job.py:103} INFO - Task exited with return code 0
