[2020-04-07 23:40:12,769] {taskinstance.py:630} INFO - Dependencies all met for <TaskInstance: Create_Target_Tables.create_table 2020-04-07T23:38:56.734963+00:00 [queued]>
[2020-04-07 23:40:12,860] {taskinstance.py:630} INFO - Dependencies all met for <TaskInstance: Create_Target_Tables.create_table 2020-04-07T23:38:56.734963+00:00 [queued]>
[2020-04-07 23:40:12,860] {taskinstance.py:841} INFO - 
--------------------------------------------------------------------------------
[2020-04-07 23:40:12,860] {taskinstance.py:842} INFO - Starting attempt 1 of 1
[2020-04-07 23:40:12,860] {taskinstance.py:843} INFO - 
--------------------------------------------------------------------------------
[2020-04-07 23:40:12,883] {taskinstance.py:862} INFO - Executing <Task(PostgresOperator): create_table> on 2020-04-07T23:38:56.734963+00:00
[2020-04-07 23:40:12,883] {base_task_runner.py:133} INFO - Running: ['airflow', 'run', 'Create_Target_Tables', 'create_table', '2020-04-07T23:38:56.734963+00:00', '--job_id', '15', '--pool', 'default_pool', '--raw', '-sd', 'DAGS_FOLDER/test.py', '--cfg_path', '/tmp/tmp9fe8heyd']
[2020-04-07 23:40:14,623] {base_task_runner.py:115} INFO - Job 15: Subtask create_table /usr/local/lib/python3.7/site-packages/airflow/configuration.py:226: FutureWarning: The task_runner setting in [core] has the old default value of 'BashTaskRunner'. This value has been changed to 'StandardTaskRunner' in the running config, but please update your config before Apache Airflow 2.0.
[2020-04-07 23:40:14,623] {base_task_runner.py:115} INFO - Job 15: Subtask create_table   FutureWarning
[2020-04-07 23:40:14,623] {base_task_runner.py:115} INFO - Job 15: Subtask create_table /usr/local/lib/python3.7/site-packages/airflow/config_templates/airflow_local_settings.py:65: DeprecationWarning: The elasticsearch_host option in [elasticsearch] has been renamed to host - the old setting has been used, but please update your config.
[2020-04-07 23:40:14,624] {base_task_runner.py:115} INFO - Job 15: Subtask create_table   ELASTICSEARCH_HOST = conf.get('elasticsearch', 'HOST')
[2020-04-07 23:40:14,624] {base_task_runner.py:115} INFO - Job 15: Subtask create_table /usr/local/lib/python3.7/site-packages/airflow/config_templates/airflow_local_settings.py:67: DeprecationWarning: The elasticsearch_log_id_template option in [elasticsearch] has been renamed to log_id_template - the old setting has been used, but please update your config.
[2020-04-07 23:40:14,624] {base_task_runner.py:115} INFO - Job 15: Subtask create_table   ELASTICSEARCH_LOG_ID_TEMPLATE = conf.get('elasticsearch', 'LOG_ID_TEMPLATE')
[2020-04-07 23:40:14,624] {base_task_runner.py:115} INFO - Job 15: Subtask create_table /usr/local/lib/python3.7/site-packages/airflow/config_templates/airflow_local_settings.py:69: DeprecationWarning: The elasticsearch_end_of_log_mark option in [elasticsearch] has been renamed to end_of_log_mark - the old setting has been used, but please update your config.
[2020-04-07 23:40:14,624] {base_task_runner.py:115} INFO - Job 15: Subtask create_table   ELASTICSEARCH_END_OF_LOG_MARK = conf.get('elasticsearch', 'END_OF_LOG_MARK')
[2020-04-07 23:40:14,879] {base_task_runner.py:115} INFO - Job 15: Subtask create_table [2020-04-07 23:40:14,878] {settings.py:252} INFO - settings.configure_orm(): Using pool settings. pool_size=5, max_overflow=10, pool_recycle=1800, pid=6557
[2020-04-07 23:40:16,382] {base_task_runner.py:115} INFO - Job 15: Subtask create_table [2020-04-07 23:40:16,378] {__init__.py:51} INFO - Using executor LocalExecutor
[2020-04-07 23:40:16,382] {base_task_runner.py:115} INFO - Job 15: Subtask create_table [2020-04-07 23:40:16,379] {dagbag.py:92} INFO - Filling up the DagBag from /usr/local/airflow/dags/test.py
[2020-04-07 23:40:16,498] {base_task_runner.py:115} INFO - Job 15: Subtask create_table [2020-04-07 23:40:16,498] {cli.py:545} INFO - Running <TaskInstance: Create_Target_Tables.create_table 2020-04-07T23:38:56.734963+00:00 [running]> on host cbfea4d5d23b
[2020-04-07 23:40:16,577] {postgres_operator.py:62} INFO - Executing: -- Set up Target table company, company_audits, log_last_company_audits_changes function and last_company_audits_changes trigger

drop view if exists last_address_record_inserted;
drop view if exists last_company_record_inserted;
drop trigger if exists last_address_audits_changes on public.address;
drop trigger if exists last_company_audits_changes on public.company;
drop function if exists log_last_address_audits_changes();
drop function if exists log_last_company_audits_changes();
drop table if exists address;
drop table if exists address_audits;
drop table if exists company;
drop table if exists company_audits;

CREATE TABLE company
(
    company_id text COLLATE pg_catalog."default",
    status character varying(255) COLLATE pg_catalog."default",
    rating_threshold character varying(255) COLLATE pg_catalog."default",
    company_name text COLLATE pg_catalog."default",
    foundation_date date,
    legal_form character varying(255) COLLATE pg_catalog."default",
    created_at date
);


CREATE TABLE IF NOT EXISTS company_audits (
   id SERIAL PRIMARY KEY,
   company_id text COLLATE pg_catalog."default",
   changed_on TIMESTAMP(6) NOT NULL
);


CREATE OR REPLACE FUNCTION log_last_company_audits_changes()
   RETURNS trigger AS $$
   BEGIN
      IF EXISTS(SELECT 1 FROM company c WHERE c.company_id = NEW.company_id) THEN
            PERFORM * FROM company_audits LIMIT 1;
      ELSE
            INSERT INTO company_audits(company_id,changed_on) VALUES(NEW.company_id,now());
      END IF;
      RETURN NEW;
   END;
   $$ LANGUAGE plpgsql;


CREATE TRIGGER last_company_audits_changes
  BEFORE INSERT
  ON company
  FOR EACH ROW
  EXECUTE PROCEDURE log_last_company_audits_changes();


-- Set up Target table address, address_audits, log_last_address_audits_changes function and last_address_audits_changes trigger
CREATE TABLE address
(
    id integer,
    company_id text COLLATE pg_catalog."default",
    country character varying(255) COLLATE pg_catalog."default",
    postal_code character varying(255) COLLATE pg_catalog."default",
    city character varying(255) COLLATE pg_catalog."default",
    district character varying(255) COLLATE pg_catalog."default",
    street character varying(255) COLLATE pg_catalog."default",
    street_number character varying(255) COLLATE pg_catalog."default",
    addition character varying(255) COLLATE pg_catalog."default",
    created_at date
);


CREATE TABLE IF NOT EXISTS address_audits (
   idx SERIAL PRIMARY KEY,
   id integer,
   company_id text COLLATE pg_catalog."default",
   changed_on TIMESTAMP(6) NOT NULL
);


CREATE OR REPLACE FUNCTION log_last_address_audits_changes()
   RETURNS trigger AS $$
   BEGIN
      IF EXISTS(SELECT 1 FROM address a WHERE a.id = NEW.id) THEN
            PERFORM * FROM address_audits LIMIT 1;
      ELSE
            INSERT INTO address_audits(id,company_id,changed_on) VALUES(NEW.id, NEW.company_id,now());
      END IF;
      RETURN NEW;
   END;
   $$ LANGUAGE plpgsql;


CREATE TRIGGER last_address_audits_changes
  BEFORE INSERT
  ON address
  FOR EACH ROW
  EXECUTE PROCEDURE log_last_address_audits_changes();

-- Set up Target table last record insert tracker as view last_address_record_inserted, last_company_record_inserted
CREATE OR REPLACE VIEW last_address_record_inserted AS
SELECT a.id, a.company_id, a.country, a.postal_code,
a.city, a.district, a.street, a.street_number, a.addition, a.created_at FROM address a
inner join (SELECT id from address_audits where changed_on = (
SELECT changed_on FROM public.address_audits order by changed_on desc limit 1)) as b
on a.id = b.id;


CREATE OR REPLACE VIEW last_company_record_inserted AS
SELECT a.company_id, a.status, a.rating_threshold, a.company_name,
a.foundation_date, a.legal_form, a.created_at FROM company a
inner join (SELECT company_id from company_audits where changed_on = (
SELECT changed_on FROM public.company_audits order by changed_on desc limit 1))as b
on a.company_id = b.company_id;
[2020-04-07 23:40:16,618] {logging_mixin.py:112} INFO - [2020-04-07 23:40:16,617] {base_hook.py:84} INFO - Using connection to: id: target. Host: sourcedb, Port: 5432, Schema: targetdb, Login: sourcedb, Password: XXXXXXXX, extra: {}
[2020-04-07 23:40:16,627] {logging_mixin.py:112} INFO - [2020-04-07 23:40:16,627] {dbapi_hook.py:171} INFO - -- Set up Target table company, company_audits, log_last_company_audits_changes function and last_company_audits_changes trigger

drop view if exists last_address_record_inserted;
drop view if exists last_company_record_inserted;
drop trigger if exists last_address_audits_changes on public.address;
drop trigger if exists last_company_audits_changes on public.company;
drop function if exists log_last_address_audits_changes();
drop function if exists log_last_company_audits_changes();
drop table if exists address;
drop table if exists address_audits;
drop table if exists company;
drop table if exists company_audits;

CREATE TABLE company
(
    company_id text COLLATE pg_catalog."default",
    status character varying(255) COLLATE pg_catalog."default",
    rating_threshold character varying(255) COLLATE pg_catalog."default",
    company_name text COLLATE pg_catalog."default",
    foundation_date date,
    legal_form character varying(255) COLLATE pg_catalog."default",
    created_at date
);


CREATE TABLE IF NOT EXISTS company_audits (
   id SERIAL PRIMARY KEY,
   company_id text COLLATE pg_catalog."default",
   changed_on TIMESTAMP(6) NOT NULL
);


CREATE OR REPLACE FUNCTION log_last_company_audits_changes()
   RETURNS trigger AS $$
   BEGIN
      IF EXISTS(SELECT 1 FROM company c WHERE c.company_id = NEW.company_id) THEN
            PERFORM * FROM company_audits LIMIT 1;
      ELSE
            INSERT INTO company_audits(company_id,changed_on) VALUES(NEW.company_id,now());
      END IF;
      RETURN NEW;
   END;
   $$ LANGUAGE plpgsql;


CREATE TRIGGER last_company_audits_changes
  BEFORE INSERT
  ON company
  FOR EACH ROW
  EXECUTE PROCEDURE log_last_company_audits_changes();


-- Set up Target table address, address_audits, log_last_address_audits_changes function and last_address_audits_changes trigger
CREATE TABLE address
(
    id integer,
    company_id text COLLATE pg_catalog."default",
    country character varying(255) COLLATE pg_catalog."default",
    postal_code character varying(255) COLLATE pg_catalog."default",
    city character varying(255) COLLATE pg_catalog."default",
    district character varying(255) COLLATE pg_catalog."default",
    street character varying(255) COLLATE pg_catalog."default",
    street_number character varying(255) COLLATE pg_catalog."default",
    addition character varying(255) COLLATE pg_catalog."default",
    created_at date
);


CREATE TABLE IF NOT EXISTS address_audits (
   idx SERIAL PRIMARY KEY,
   id integer,
   company_id text COLLATE pg_catalog."default",
   changed_on TIMESTAMP(6) NOT NULL
);


CREATE OR REPLACE FUNCTION log_last_address_audits_changes()
   RETURNS trigger AS $$
   BEGIN
      IF EXISTS(SELECT 1 FROM address a WHERE a.id = NEW.id) THEN
            PERFORM * FROM address_audits LIMIT 1;
      ELSE
            INSERT INTO address_audits(id,company_id,changed_on) VALUES(NEW.id, NEW.company_id,now());
      END IF;
      RETURN NEW;
   END;
   $$ LANGUAGE plpgsql;


CREATE TRIGGER last_address_audits_changes
  BEFORE INSERT
  ON address
  FOR EACH ROW
  EXECUTE PROCEDURE log_last_address_audits_changes();

-- Set up Target table last record insert tracker as view last_address_record_inserted, last_company_record_inserted
CREATE OR REPLACE VIEW last_address_record_inserted AS
SELECT a.id, a.company_id, a.country, a.postal_code,
a.city, a.district, a.street, a.street_number, a.addition, a.created_at FROM address a
inner join (SELECT id from address_audits where changed_on = (
SELECT changed_on FROM public.address_audits order by changed_on desc limit 1)) as b
on a.id = b.id;


CREATE OR REPLACE VIEW last_company_record_inserted AS
SELECT a.company_id, a.status, a.rating_threshold, a.company_name,
a.foundation_date, a.legal_form, a.created_at FROM company a
inner join (SELECT company_id from company_audits where changed_on = (
SELECT changed_on FROM public.company_audits order by changed_on desc limit 1))as b
on a.company_id = b.company_id;
[2020-04-07 23:40:16,756] {postgres_operator.py:67} INFO - NOTICE:  view "last_address_record_inserted" does not exist, skipping

[2020-04-07 23:40:16,757] {postgres_operator.py:67} INFO - NOTICE:  view "last_company_record_inserted" does not exist, skipping

[2020-04-07 23:40:16,757] {postgres_operator.py:67} INFO - NOTICE:  relation "public.address" does not exist, skipping

[2020-04-07 23:40:16,757] {postgres_operator.py:67} INFO - NOTICE:  relation "public.company" does not exist, skipping

[2020-04-07 23:40:16,757] {postgres_operator.py:67} INFO - NOTICE:  table "address" does not exist, skipping

[2020-04-07 23:40:16,757] {postgres_operator.py:67} INFO - NOTICE:  table "company" does not exist, skipping

[2020-04-07 23:40:17,700] {logging_mixin.py:112} INFO - [2020-04-07 23:40:17,700] {local_task_job.py:124} WARNING - Time since last heartbeat(0.02 s) < heartrate(5.0 s), sleeping for 4.982938 s
[2020-04-07 23:40:22,689] {logging_mixin.py:112} INFO - [2020-04-07 23:40:22,689] {local_task_job.py:103} INFO - Task exited with return code 0
